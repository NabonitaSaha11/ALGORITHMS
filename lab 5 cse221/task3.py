# -*- coding: utf-8 -*-
"""task3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DHSPF4YEg_KdQ65pZPJ8IkH7avoO_Sr7
"""

input=open('input3_2.txt', 'r')
output=open('output3_2.txt', 'w')
n=input.readline().split()
N=int(n[0])
M=int(n[1])

def dfs(graph,node,visit,stack1):

    visit[node]=True
    for adjacent in graph[node]:
        if not visit[adjacent]:
            dfs(graph,adjacent,visit,stack1)
    stack1.append(node)

def transpose(graph):

    num=len(graph)
    tgraph=[]
    for i in range(num):
      tgraph.append([])
    for node in range(num):
        for adj in graph[node]:
            tgraph[adj].append(node)
    return tgraph

def find_scc(graph):

    num1=len(graph)
    visit=[False]*num1
    stack2=[]

    for node in range(num1):
        if  visit[node]==False:
            dfs(graph,node,visit,stack2)

    transposed_graph=transpose(graph)
    visit=[False]*num1
    seq=[]
    while len(stack2)!=0:
        node=stack2.pop()
        if  visit[node]==False:
            scc=[]
            dfs(transposed_graph, node, visit, scc)
            scc.sort()
            seq.append(scc)
    seq.sort()
    return seq



graph=[]
for i in range(N):
  graph.append([])
for j in range(M):
    temp=map(int, input.readline().strip().split())
    u,v=temp
    graph[u-1].append(v-1)


sequence = find_scc(graph)
for scc in sequence:
    grouped_nodes = []
    for node in scc:
        grouped_nodes.append(node + 1)
    for i in grouped_nodes:
      output.write(str(i)+" ")
    output.write("\n")